/*
 * Copyright (c) 2018 Nordic Semiconductor ASA.
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <spm.h>

/*
 * Example code for a Secure Partition Manager application.
 * The application uses the SPM to set the security attributions of
 * the MCU resources (Flash, SRAM and Peripherals). It uses the core
 * TrustZone-M API to prepare the MCU to jump into Non-Secure firmware
 * execution.
 *
 * The following security configuration for Flash and SRAM is applied:
 *
 *                FLASH
 *  1 MB  |---------------------|
 *        |                     |
 *        |                     |
 *        |                     |
 *        |                     |
 *        |                     |
 *        |     Non-Secure      |
 *        |       Flash         |
 *        |                     |
 * 256 kB |---------------------|
 *        |                     |
 *        |     Secure          |
 *        |      Flash          |
 *  0 kB  |---------------------|
 *
 *
 *                SRAM
 * 256 kB |---------------------|
 *        |                     |
 *        |                     |
 *        |                     |
 *        |     Non-Secure      |
 *        |    SRAM (image)     |
 *        |                     |
 * 128 kB |.................... |
 *        |     Non-Secure      |
 *        |  SRAM (BSD Library) |
 *  64 kB |---------------------|
 *        |      Secure         |
 *        |       SRAM          |
 *  0 kB  |---------------------|
 */


#include <aarch32/cortex_m/tz.h>
#include "blst.h"

blst_scalar sk;
blst_scalar secret_keys_store[10];

__TZ_NONSECURE_ENTRY_FUNC
static int cmd_keygen(const struct shell *shell, size_t argc, char **argv)
{
	ARG_UNUSED(argc);
	ARG_UNUSED(argv);
        
        // For security, IKM MUST be infeasible to guess, e.g., generated by a trusted
        // source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.
        unsigned char ikm[32];
	const int random_number_len = 144;     
        uint8_t random_number[random_number_len];
        size_t olen = random_number_len;
        int ret;

        ret = spm_request_random_number(random_number, random_number_len, &olen);
        if (ret != 0) {
           printk("Could not get random number (err: %d)\n", ret);
        }
        
        //TO DO: IMPLEMENTATION OF HASH FOR RANDOM NUMBER STRING
        //ocrypto_sha256(ikm, random_number, random_number_len);

        for(int i = 0; i < sizeof(ikm); i++){
          ikm[i] = random_number[i];
        } 

        // key_info is an optional parameter.  This parameter MAY be used to derive
        // multiple independent keys from the same IKM.  By default, key_info is the empty string.
        char info[] = {
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
        
        //Secret key (256-bit scalar)
        blst_keygen(&sk, ikm, sizeof(ikm), info, sizeof(info));
        secret_keys_store[keys_counter] = sk;
        keys_counter++;
                
        uint8_t priv_key_bin[32];
        blst_bendian_from_scalar(priv_key_bin, &sk);

        char priv_key_hex2[64];
        if(bin2hex(priv_key_bin, sizeof(priv_key_bin), priv_key_hex2, sizeof(priv_key_hex2)) == 0) {
          printf("Error2\n");
        }

        printf("Secret key: \n");
        printf("0x");
        printf("%s\n", priv_key_hex2);

        //The secret key allow us to generate the associated public key
        blst_p1 pk;
        byte out[48];
        char public_key_hex[96];
        blst_sk_to_pk_in_g1(&pk, &sk);
        blst_p1_to_affine(&pk2, &pk);
        blst_p1_compress(out, &pk);

        printf("Public key: \n");
        if(bin2hex(&out, sizeof(out), public_key_hex, sizeof(public_key_hex)) == 0) {
          printf("Error3\n");
        }
     
        int cont = keys_counter - 1;
        for(int i = 0; i < 96; i++){
            public_keys_hex_store[i+96*cont] = public_key_hex[i];
        }
        
        printf("0x");
        for(int i = 0; i < 96; i++) {
          printf("%c", public_key_hex[i]);
        }
        printf("\n");

	return 0;
}

SHELL_CMD_ARG_REGISTER(keygen, NULL, "Generates secret key and public key", cmd_keygen, 1, 0);

void main(void)
{
	spm_config();
	spm_jump();
}