/*
 * Copyright (c) 2018 Nordic Semiconductor ASA.
 *
 * SPDX-License-Identifier: LicenseRef-Nordic-5-Clause
 */

#include <spm.h>

/*
 * Example code for a Secure Partition Manager application.
 * The application uses the SPM to set the security attributions of
 * the MCU resources (Flash, SRAM and Peripherals). It uses the core
 * TrustZone-M API to prepare the MCU to jump into Non-Secure firmware
 * execution.
 *
 * The following security configuration for Flash and SRAM is applied:
 *
 *                FLASH
 *  1 MB  |---------------------|
 *        |                     |
 *        |                     |
 *        |                     |
 *        |                     |
 *        |                     |
 *        |     Non-Secure      |
 *        |       Flash         |
 *        |                     |
 * 256 kB |---------------------|
 *        |                     |
 *        |     Secure          |
 *        |      Flash          |
 *  0 kB  |---------------------|
 *
 *
 *                SRAM
 * 256 kB |---------------------|
 *        |                     |
 *        |                     |
 *        |                     |
 *        |     Non-Secure      |
 *        |    SRAM (image)     |
 *        |                     |
 * 128 kB |.................... |
 *        |     Non-Secure      |
 *        |  SRAM (BSD Library) |
 *  64 kB |---------------------|
 *        |      Secure         |
 *        |       SRAM          |
 *  0 kB  |---------------------|
 */


#include <aarch32/cortex_m/tz.h>
#include <blst.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/printk.h>
#include <secure_services.h>


blst_scalar sk;
blst_scalar secret_keys_store[10];
blst_scalar sk_sign;

__TZ_NONSECURE_ENTRY_FUNC
int public_key_to_sk(char * public_key_hex, char* public_keys_hex_store, int keys_counter, int offset){

    int ret = 0;
    char* addr = strstr(public_keys_hex_store, public_key_hex + offset);
    if(addr != NULL){
        int index = addr - public_keys_hex_store;
        sk_sign = secret_keys_store[index];
    }else{
        ret = -1;
    }
    
    return ret;
}

__TZ_NONSECURE_ENTRY_FUNC
void ikm_sk(int* keys_counter, char* info){
        // For security, IKM MUST be infeasible to guess, e.g., generated by a trusted
        // source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.
        unsigned char ikm[32];
	const int random_number_len = 144;     
        uint8_t random_number[random_number_len];
        size_t olen = random_number_len;
        int ret;

        ret = spm_request_random_number_nse(random_number, random_number_len, &olen);
        
        //TO DO: IMPLEMENTATION OF HASH FOR RANDOM NUMBER STRING
        //ocrypto_sha256(ikm, random_number, random_number_len);

        for(int i = 0; i < sizeof(ikm); i++){
          ikm[i] = random_number[i];
        }
        
        //Secret key (256-bit scalar)
        blst_keygen(&sk, ikm, sizeof(ikm), info, sizeof(info));
        secret_keys_store[*keys_counter] = sk;
        (*keys_counter)++;
}

__TZ_NONSECURE_ENTRY_FUNC
void ikm_sk_bm(char* info){
        // For security, IKM MUST be infeasible to guess, e.g., generated by a trusted
        // source of randomness. IKM MUST be at least 32 bytes long, but it MAY be longer.
        unsigned char ikm[32];
	const int random_number_len = 144;     
        uint8_t random_number[random_number_len];
        size_t olen = random_number_len;
        int ret;

        ret = spm_request_random_number_nse(random_number, random_number_len, &olen);
        
        //TO DO: IMPLEMENTATION OF HASH FOR RANDOM NUMBER STRING
        //ocrypto_sha256(ikm, random_number, random_number_len);

        for(int i = 0; i < sizeof(ikm); i++){
          ikm[i] = random_number[i];
        }
        
        //Secret key (256-bit scalar)
        blst_keygen(&sk, ikm, sizeof(ikm), info, sizeof(info));
        //secret_keys_store[*keys_counter] = sk;
        //(*keys_counter)++;
}

__TZ_NONSECURE_ENTRY_FUNC
void sk_to_pk(blst_p1* pk){
        blst_sk_to_pk_in_g1(pk, &sk);
}

__TZ_NONSECURE_ENTRY_FUNC
void sign_pk(blst_p2* sig, blst_p2* hash){
        blst_sign_pk_in_g1(sig, hash, &sk_sign);
}

__TZ_NONSECURE_ENTRY_FUNC
void sign_pk_bm(blst_p2* sig, blst_p2* hash){
        blst_sign_pk_in_g1(sig, hash, &sk);
}

void main(void)
{
	spm_config();
	spm_jump();
}