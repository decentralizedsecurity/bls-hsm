{"version":3,"sources":["../src/key-derivation.ts"],"names":["ikmToLamportSK","ikm","salt","bIKM","Buffer","from","prk","HKDF","extract","SHA256","okm","expand","alloc","Array","length","_","i","slice","parentSKToLamportPK","parentSK","index","BN","toArrayLike","lamport0","notIkm","map","value","lamport1","lamportPK","concat","digest","hkdfModR","keyInfo","sk","eqn","okmBN","r","mod","toArray","deriveChildSK","isBuffer","Error","Number","isSafeInteger","compressedLamportPK","deriveMasterSK","deriveChildSKMultiple","indices","key","forEach"],"mappings":"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","sourcesContent":["import SHA256 from \"bcrypto/lib/sha256\";\nimport HKDF from \"bcrypto/lib/hkdf\";\nimport BN from \"bn.js\";\nimport {Buffer} from \"buffer\";\n\nfunction ikmToLamportSK(ikm: Buffer, salt: Buffer): Buffer[] {\n  const bIKM = Buffer.from(ikm);\n  const prk = HKDF.extract(SHA256, bIKM, salt);\n  const okm = HKDF.expand(SHA256, prk, Buffer.alloc(0), 8160); // 8160 = 255 * 32\n  return Array.from({length: 255}, (_, i) => okm.slice(i*32, (i+1)*32));\n}\n\nfunction parentSKToLamportPK(parentSK: Buffer, index: number): Buffer {\n  const salt = (new BN(index)).toArrayLike(Buffer, \"be\", 4);\n  const ikm = Buffer.from(parentSK);\n  const lamport0 = ikmToLamportSK(ikm, salt);\n  const notIkm = Buffer.from(ikm.map((value) => ~value));\n  const lamport1 = ikmToLamportSK(notIkm, salt);\n  const lamportPK = lamport0.concat(lamport1).map((value) => SHA256.digest(value));\n  return SHA256.digest(Buffer.concat(lamportPK));\n}\n\nfunction hkdfModR(ikm: Buffer, keyInfo: Buffer = Buffer.alloc(0)): Buffer {\n  let salt = Buffer.from(\"BLS-SIG-KEYGEN-SALT-\", \"ascii\");\n  let sk = new BN(0);\n  while (sk.eqn(0)) {\n    salt = SHA256.digest(salt);\n    const prk = HKDF.extract(\n      SHA256,\n      Buffer.concat([ikm, Buffer.alloc(1)]),\n      salt\n    );\n    const okm = HKDF.expand(SHA256, prk, Buffer.concat([keyInfo, Buffer.from([0, 48])]), 48);\n    const okmBN = new BN(okm, \"hex\", \"be\");\n    const r = new BN(\"52435875175126190479447740508185965837690552500527637822603658699938581184513\");\n    sk = okmBN.mod(r);\n  }\n  return Buffer.from(sk.toArray(\"be\", 32));\n}\n\nexport function deriveChildSK(parentSK: Buffer, index: number): Buffer {\n  if (!Buffer.isBuffer(parentSK) || parentSK.length !== 32) {\n    throw new Error(\"parentSK must be a Buffer of 32 bytes\");\n  }\n  if (!Number.isSafeInteger(index) || index < 0 || index >= 2 ** 32) {\n    throw new Error(\"index must be 0 <= i < 2**32\");\n  }\n  const compressedLamportPK = parentSKToLamportPK(parentSK, index);\n  return hkdfModR(compressedLamportPK);\n}\n\nexport function deriveMasterSK(ikm: Buffer): Buffer {\n  if (!Buffer.isBuffer(ikm)) {\n    throw new Error(\"ikm must be a Buffer\");\n  }\n  if (ikm.length < 32) {\n    throw new Error(\"ikm must be >= 32 bytes\");\n  }\n  return hkdfModR(ikm);\n}\n\nexport function deriveChildSKMultiple(parentSK: Buffer, indices: number[]): Buffer {\n  let key = parentSK;\n  indices.forEach(i => key = deriveChildSK(key, i));\n  return key;\n}\n"],"file":"key-derivation.js"}